# 自動リリースワークフロー セットアップガイド

## 概要

PRラベルに基づいてセマンティックバージョニングを自動計算し、リリースPRの作成からGitHubリリースの公開までを自動化するワークフローです。

## 必要なファイル

```
.github/
├── workflows/
│   ├── create-release-pr.yml
│   ├── label-from-commits.yml
│   └── release.yml
└── scripts/
    ├── compute-next-version.js
    └── create-or-update-pr.js
```

## 必要なPRラベル

以下のラベルをリポジトリに作成してください：

| ラベル | バージョン変更 | 説明 |
|--------|---------------|------|
| `breaking` | major (x.0.0) | 破壊的変更 |
| `feat` | minor (0.x.0) | 新機能 |
| `fix` | patch (0.0.x) | バグ修正 |

## フロー

```
1. Conventional Commits形式でコミットしてPRを作成
        ↓
2. label-from-commits.yml が自動実行
   - コミットメッセージを解析
   - breaking/feat/fix等のラベルを自動付与
        ↓
3. PRをレビュー・マージ
        ↓
4. create-release-pr.yml が自動実行
   - 次バージョンを自動計算
   - ドラフトリリース作成
   - release/vX.X.X ブランチでPR作成
        ↓
5. リリースPRをレビュー・マージ
        ↓
6. release.yml が自動実行
   - Gitタグ作成・push
   - GitHubリリース公開
```

---

## ファイル内容

### `.github/workflows/label-from-commits.yml`

Conventional Commits形式のコミットメッセージを解析し、PRに自動でラベルを付与するワークフローです。

```yaml
name: "Label PR from commit messages"

on:
    pull_request:
        types: [opened, synchronize, reopened, edited]

permissions:
    contents: read
    pull-requests: write

jobs:
    label-from-commits:
        runs-on: ubuntu-slim
        steps:
            - name: Label PR based on Conventional Commits
              uses: actions/github-script@v7
              with:
                  github-token: ${{ secrets.GITHUB_TOKEN }}
                  script: |
                      const pr = context.payload.pull_request;
                      const owner = context.repo.owner;
                      const repo = context.repo.repo;
                      const pull_number = pr.number;

                      // PR に紐づくコミット一覧を取得
                      const commits = await github.paginate(
                        github.rest.pulls.listCommits,
                        { owner, repo, pull_number }
                      );

                      // コミットメッセージ（1行目）を取得
                      const summaries = commits.map(c =>
                        c.commit.message.split('\n')[0]
                      );

                      // ラベル候補を決める
                      const labelsToAdd = new Set();

                      for (const msg of summaries) {
                        // Conventional Commits の type 部分を取得
                        // 例: feat(scope): xxx → type = feat
                        // 例: feat!: xxx または feat(scope)!: xxx → breaking change
                        const match = msg.match(/^(\w+)(\(.+\))?(!)?:\s+/);
                        if (!match) continue;

                        const type = match[1];
                        const hasBreakingMarker = match[3] === '!';

                        // ! がついている場合は breaking change
                        if (hasBreakingMarker) {
                          labelsToAdd.add('breaking');
                        }

                        // type をそのままラベルとして付与
                        labelsToAdd.add(type);
                      }

                      // BREAKING CHANGE の検出（本文まで含めて再判定）
                      for (const c of commits) {
                        if (c.commit.message.includes('BREAKING CHANGE')) {
                          labelsToAdd.add('breaking');
                        }
                      }

                      if (labelsToAdd.size === 0) {
                        console.log('No Conventional Commit types detected. Skipping label.');
                        return;
                      }

                      // すでに付いているラベルとマージ
                      const { data: existingLabels } = await github.rest.issues.listLabelsOnIssue({
                        owner,
                        repo,
                        issue_number: pull_number,
                      });

                      const existingNames = existingLabels.map(l => l.name);
                      const finalLabels = Array.from(labelsToAdd).filter(
                        l => !existingNames.includes(l)
                      );

                      if (finalLabels.length === 0) {
                        console.log('No new labels to add.');
                        return;
                      }

                      await github.rest.issues.addLabels({
                        owner,
                        repo,
                        issue_number: pull_number,
                        labels: finalLabels,
                      });

                      console.log('Added labels:', finalLabels);
```

#### Conventional Commits形式について

このワークフローは [Conventional Commits](https://www.conventionalcommits.org/) 形式のコミットメッセージを認識します。

**基本形式:**
```
<type>(<scope>): <description>

[optional body]

[optional footer(s)]
```

**例:**
| コミットメッセージ | 付与されるラベル |
|-------------------|-----------------|
| `feat: add login button` | `feat` |
| `fix(auth): resolve token expiration issue` | `fix` |
| `feat!: change API response format` | `feat`, `breaking` |
| `refactor(core): simplify logic` | `refactor` |
| `docs: update README` | `docs` |

**Breaking Changeの検出:**
- コミットタイプに `!` が付いている場合（例: `feat!:`, `fix!:`）
- コミット本文に `BREAKING CHANGE` が含まれている場合

---

### `.github/workflows/create-release-pr.yml`

```yaml
name: Create Release PR

on:
  push:
    branches:
      - main

permissions:
  contents: write
  pull-requests: write

jobs:
  skip-if-released:
    runs-on: ubuntu-latest
    outputs:
      skip_release_pr: ${{ steps.check-release-commit.outputs.skip_release_pr }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Skip if the release commit is merged
        id: check-release-commit
        run: |
          latest_commit_message=$(git log -1 --pretty=%B)
          if echo "$latest_commit_message" | grep -q "chore: release v"; then
            echo "skip_release_pr=true" >> $GITHUB_OUTPUT
          else
            echo "skip_release_pr=false" >> $GITHUB_OUTPUT
          fi

  create-release-pr:
    runs-on: ubuntu-latest
    needs: skip-if-released
    if: needs.skip-if-released.outputs.skip_release_pr == 'false'
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Fetch all tags
        run: git fetch --tags

      - name: Get latest semver tag
        id: latest-tag
        run: |
          latest_tag=$(git tag -l | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n 1)
          if [ -z "$latest_tag" ]; then
            latest_tag="0.0.0"
          fi
          echo "latest_tag=$latest_tag" >> $GITHUB_OUTPUT

      - name: Get merged PRs since latest tag
        id: get-prs
        env:
          GH_TOKEN: ${{ github.token }}
          LATEST_TAG: ${{ steps.latest-tag.outputs.latest_tag }}
        run: |
          if [ "$LATEST_TAG" = "0.0.0" ]; then
            base_sha=$(git rev-list --max-parents=0 HEAD)
          else
            base_sha=$(git rev-list -n 1 "$LATEST_TAG")
          fi
          commits=$(git rev-list ${base_sha}..HEAD)
          excluded_labels="skip-changelog,duplicate,invalid"
          all_labels=""
          for commit_sha in $commits; do
            pr_number=$(gh pr list --search "$commit_sha" --state merged --json number --jq '.[0].number' || echo "")
            if [ -n "$pr_number" ]; then
              pr_labels=$(gh pr view "$pr_number" --json labels --jq '.labels[].name' | tr '\n' ',' || echo "")
              if [ -n "$pr_labels" ]; then
                all_labels="${all_labels}${pr_labels}"
              fi
            fi
          done
          filtered_labels=$(echo "$all_labels" | tr ',' '\n' | grep -v -E "^(${excluded_labels})$" | sort -u | tr '\n' ',' | sed 's/,$//')
          echo "labels=$filtered_labels" >> $GITHUB_OUTPUT

      - name: Compute next version
        id: compute
        env:
          LATEST_TAG: ${{ steps.latest-tag.outputs.latest_tag }}
          LABELS: ${{ steps.get-prs.outputs.labels }}
        run: |
          result=$(node .github/scripts/compute-next-version.js "$LATEST_TAG" "$LABELS")
          next_tag=$(echo "$result" | jq -r '.nextTag')
          bump_type=$(echo "$result" | jq -r '.bumpType')
          echo "next_tag=$next_tag" >> $GITHUB_OUTPUT
          echo "bump_type=$bump_type" >> $GITHUB_OUTPUT

      - name: Create draft release
        env:
          GH_TOKEN: ${{ github.token }}
          NEXT_TAG: ${{ steps.compute.outputs.next_tag }}
          LATEST_TAG: ${{ steps.latest-tag.outputs.latest_tag }}
        run: |
          existing_draft=$(gh release list --exclude-pre-releases | grep "Release $NEXT_TAG" | grep "Draft" || echo "")
          if [ -n "$existing_draft" ]; then
            gh release delete "$NEXT_TAG" --yes
          fi
          gh release create "$NEXT_TAG" \
            --title "Release $NEXT_TAG" \
            --draft \
            --generate-notes \
            --notes-start-tag "$LATEST_TAG"

      - name: Create or update release PR
        env:
          GH_TOKEN: ${{ github.token }}
          NEXT_TAG: ${{ steps.compute.outputs.next_tag }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          release_notes=$(gh release view "$NEXT_TAG" --json body --jq '.body')
          node .github/scripts/create-or-update-pr.js "$NEXT_TAG" "$release_notes"
```

### `.github/workflows/release.yml`

```yaml
name: Release

on:
  pull_request:
    types:
      - closed
    branches:
      - main

permissions:
  contents: write

jobs:
  publish-release:
    if: github.event.pull_request.merged == true && startsWith(github.event.pull_request.head.ref, 'release/')
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Extract version from branch name
        id: extract-version
        run: |
          branch_name="${{ github.event.pull_request.head.ref }}"
          version="${branch_name#release/}"
          echo "version=$version" >> $GITHUB_OUTPUT

      - name: Create and push tag
        env:
          VERSION: ${{ steps.extract-version.outputs.version }}
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"
          git tag -a "$VERSION" -m "Release $VERSION"
          git push origin "$VERSION"

      - name: Publish draft release
        env:
          GH_TOKEN: ${{ github.token }}
          VERSION: ${{ steps.extract-version.outputs.version }}
        run: |
          draft_exists=$(gh release view "$VERSION" --json isDraft --jq '.isDraft' || echo "false")
          if [ "$draft_exists" = "true" ]; then
            gh release edit "$VERSION" --draft=false
          else
            previous_tag=$(git tag -l | grep -E '^v?[0-9]+\.[0-9]+\.[0-9]+$' | sort -V | tail -n 2 | head -n 1)
            if [ -z "$previous_tag" ]; then
              gh release create "$VERSION" --title "Release $VERSION" --generate-notes
            else
              gh release create "$VERSION" --title "Release $VERSION" --generate-notes --notes-start-tag "$previous_tag"
            fi
          fi
```

### `.github/scripts/compute-next-version.js`

```javascript
#!/usr/bin/env node

const args = process.argv.slice(2);
if (args.length !== 2) {
  console.error('Usage: compute-next-version.js <latestTag> <labelsCsv>');
  process.exit(1);
}

const [latestTag, labelsCsv] = args;

function parseSemver(tag) {
  const match = tag.match(/^v?(\d+)\.(\d+)\.(\d+)$/);
  if (!match) throw new Error(`Invalid semver tag: ${tag}`);
  return {
    major: parseInt(match[1], 10),
    minor: parseInt(match[2], 10),
    patch: parseInt(match[3], 10)
  };
}

function determineBumpType(labels) {
  const labelSet = new Set(labels.filter(l => l.trim()));
  if (labelSet.has('breaking')) return 'major';
  if (labelSet.has('feat')) return 'minor';
  if (labelSet.has('fix')) return 'patch';
  return null;
}

function bumpVersion(version, bumpType) {
  const newVersion = { ...version };
  switch (bumpType) {
    case 'major':
      newVersion.major += 1;
      newVersion.minor = 0;
      newVersion.patch = 0;
      break;
    case 'minor':
      newVersion.minor += 1;
      newVersion.patch = 0;
      break;
    case 'patch':
      newVersion.patch += 1;
      break;
  }
  return newVersion;
}

function formatTag(version) {
  return `v${version.major}.${version.minor}.${version.patch}`;
}

try {
  const currentVersion = parseSemver(latestTag);
  const labels = labelsCsv ? labelsCsv.split(',').map(l => l.trim()) : [];
  const bumpType = determineBumpType(labels);

  if (!bumpType) {
    console.error('ERROR: No version-related labels (breaking, feat, fix) found.');
    process.exit(1);
  }

  const nextVersion = bumpVersion(currentVersion, bumpType);
  const result = {
    nextTag: formatTag(nextVersion),
    bumpType,
    currentTag: latestTag,
    labels: labels.filter(l => l)
  };
  console.log(JSON.stringify(result, null, 2));
} catch (error) {
  console.error('Error:', error.message);
  process.exit(1);
}
```

### `.github/scripts/create-or-update-pr.js`

```javascript
#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');

const args = process.argv.slice(2);
if (args.length !== 2) {
  console.error('Usage: create-or-update-pr.js <version> <releaseNotes>');
  process.exit(1);
}

const [version, releaseNotes] = args;
const branchName = `release/${version}`;
const baseBranch = 'main';

function exec(command, options = {}) {
  try {
    const result = execSync(command, {
      encoding: 'utf8',
      stdio: options.silent ? 'pipe' : 'inherit',
      ...options
    });
    return result ? result.trim() : '';
  } catch (error) {
    if (!options.ignoreError) throw error;
    return '';
  }
}

try {
  const remoteBranchExists = exec(
    `git ls-remote --heads origin ${branchName}`,
    { silent: true, ignoreError: true }
  );

  exec(`git checkout -b ${branchName}`);
  exec(`git commit --allow-empty -m "chore(release): prepare ${version}"`);

  const existingPr = exec(
    `gh pr list --head ${branchName} --base ${baseBranch} --json number --jq '.[0].number'`,
    { silent: true, ignoreError: true }
  );

  if (remoteBranchExists) {
    exec(`git push --force-with-lease origin ${branchName}`);
  } else {
    exec(`git push -u origin ${branchName}`);
  }

  const prBody = `## Release ${version}

This PR prepares the release of ${version}.

### Release notes

${releaseNotes}

---

**Note**: This PR was automatically generated.`;

  const tempBodyFile = '/tmp/pr-body.md';
  fs.writeFileSync(tempBodyFile, prBody);

  if (existingPr) {
    exec(`gh pr edit ${existingPr} --body-file ${tempBodyFile}`);
  } else {
    exec(`gh pr create --title "chore: release ${version}" --base ${baseBranch} --head ${branchName} --body-file ${tempBodyFile}`, { silent: true });
  }

  exec(`git checkout ${baseBranch}`);
} catch (error) {
  console.error('Error:', error.message);
  process.exit(1);
}
```

---

## セットアップ手順

1. 上記4ファイルをリポジトリにコピー
2. スクリプトに実行権限を付与: `chmod +x .github/scripts/*.js`
3. リポジトリにラベル `breaking`, `feat`, `fix` を作成（下記参照）
4. PRにラベルを付けてマージすると自動でリリースPRが作成される

---

## PRラベルのセットアップ

### GitHub CLI でラベルを作成する方法

以下のコマンドでラベルを一括作成できます：

```bash
gh label create breaking --description "破壊的変更 (major version bump)" --color "D93F0B"
gh label create feat --description "新機能 (minor version bump)" --color "0E8A16"
gh label create fix --description "バグ修正 (patch version bump)" --color "FBCA04"
```

### GitHub UI でラベルを作成する方法

1. リポジトリの **Issues** または **Pull requests** タブを開く
2. **Labels** ボタンをクリック
3. **New label** ボタンをクリック
4. 以下の情報を入力して作成：

| ラベル名 | 説明 | 推奨色 |
|---------|------|--------|
| `breaking` | 破壊的変更 (major version bump) | `#D93F0B` (赤) |
| `feat` | 新機能 (minor version bump) | `#0E8A16` (緑) |
| `fix` | バグ修正 (patch version bump) | `#FBCA04` (黄) |

### PRへのラベル付与

PRにラベルを付与する方法は以下の通りです：

**GitHub UI:**
1. PRページの右サイドバーにある **Labels** セクションをクリック
2. 適切なラベル（`breaking`, `feat`, `fix`）を選択

**GitHub CLI:**
```bash
# 新規PRを作成する際にラベルを付与
gh pr create --title "Add new feature" --label feat

# 既存のPRにラベルを追加
gh pr edit <PR番号> --add-label feat
```

### 注意事項

- 1つのPRに複数のラベルが付いている場合、**最も影響の大きいラベルが優先**されます
  - 優先順位: `breaking` > `feat` > `fix`
- `breaking`, `feat`, `fix` のいずれのラベルも付いていないPRがマージされた場合、リリースPR作成時にエラーとなります
- `skip-changelog`, `duplicate`, `invalid` ラベルは除外され、バージョン計算に影響しません

